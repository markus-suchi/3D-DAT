Blender Images with numpy:

1)
https://blender.stackexchange.com/questions/40562/how-to-combine-images-using-python
do i need this line?
bpy.ops.image.new(name="view.png", width=1024, height=1024)

image = bpy.data.images['view.png']
image.pixels = numpy_array.tolist()

2)
https://blender.stackexchange.com/questions/92692/how-to-convert-numpy-array-into-image-and-add-it-to-images-inside-bpy
if "TestImg.png" not in bpy.data.images.keys():
    bpy.data.images.new("TestImg.png", width=128, height=128, alpha=True, float_buffer=False)
outputImg = bpy.data.images["TestImg.png"] 
input_res = int(math.sqrt(outputImg.size[0]))
np_out_img = np.zeros((input_res,input_res,4), dtype = np.float16)
outputImg.pixels = np_out_img.ravel()


Identity quaternion:
(w,x,y,z) = (1,0,0,0)
https://github.com/clemense/quaternion-conventions
xyzw == "scalar-last format"

3) install packages within blender
cd /path/to/blender/python/bin
./python -m ensurepip
./python -m pip install scipy

4) organized pointclouds from depth/intrinsics (graspnet): No Color!
def create_point_cloud_from_depth_image(depth, camera, organized=True):
    """ Generate point cloud using depth image only.
        Input:
            depth: [numpy.ndarray, (H,W), numpy.float32]
                depth image
            camera: [CameraInfo]
                camera intrinsics
            organized: bool
                whether to keep the cloud in image shape (H,W,3)
        Output:
            cloud: [numpy.ndarray, (H,W,3)/(H*W,3), numpy.float32]
                generated cloud, (H,W,3) for organized=True, (H*W,3) for organized=False
    """
    assert(depth.shape[0] == camera.height and depth.shape[1] == camera.width)
    xmap = np.arange(camera.width)
    ymap = np.arange(camera.height)
    xmap, ymap = np.meshgrid(xmap, ymap)
    points_z = depth / camera.scale
    points_x = (xmap - camera.cx) * points_z / camera.fx
    points_y = (ymap - camera.cy) * points_z / camera.fy
    cloud = np.stack([points_x, points_y, points_z], axis=-1)
    if not organized:
        cloud = cloud.reshape([-1, 3])
    return cloud
    
5) import obj/ply as blender meshes

import os
import os
from typing import List

import bpy

from src.utility.MeshObjectUtility import MeshObject


class ObjectLoader:

    @staticmethod
    def load(filepath: str, cached_objects: dict = None, **kwargs) -> List[MeshObject]:
        """ Import all objects for the given file and returns the loaded objects
        In .obj files a list of objects can be saved in.
        In .ply files only one object can saved so the list has always at most one element
        :param filepath: the filepath to the location where the data is stored
        :param cached_objects: a dict of filepath to objects, which have been loaded before, to avoid reloading (the dict is updated in this function)
        :param kwargs: all other params are handed directly to the bpy loading fct. check the corresponding documentation
        :return: The list of loaded mesh objects.
        """
        if os.path.exists(filepath):
            if cached_objects is not None and isinstance(cached_objects, dict):
                if filepath in cached_objects.keys():
                    created_obj = []
                    for obj in cached_objects[filepath]:
                        # duplicate the object
                        created_obj.append(obj.duplicate())
                    return created_obj
                else:
                    loaded_objects = ObjectLoader.load(filepath, cached_objects=None, **kwargs)
                    cached_objects[filepath] = loaded_objects
                    return loaded_objects
            else:
                # save all selected objects
                previously_selected_objects = set(bpy.context.selected_objects)
                if filepath.endswith('.obj'):
                    # load an .obj file:
                    bpy.ops.import_scene.obj(filepath=filepath, **kwargs)
                elif filepath.endswith('.ply'):
                    # load a .ply mesh
                    bpy.ops.import_mesh.ply(filepath=filepath, **kwargs)
                    # add a default material to ply file
                    mat = bpy.data.materials.new(name="ply_material")
                    mat.use_nodes = True
                    loaded_objects = list(set(bpy.context.selected_objects) - previously_selected_objects)
                    for obj in loaded_objects:
                        obj.data.materials.append(mat)

                # return all currently selected objects
                return MeshObject.convert_to_meshes(list(set(bpy.context.selected_objects) - previously_selected_objects))
        else:
            raise Exception("The given filepath does not exist: {}".format(filepath))





